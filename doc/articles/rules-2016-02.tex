
\documentclass{IOS-Book-Article}     %[seceqn,secfloat,secthm]
\usepackage{mathptmx}
\usepackage[shortcuts]{extdash}
\usepackage{fixltx2e}
%\usepackage[T1]{fontenc}
%\usepackage{times}%
%
%%%%%%%%%%% Put your definitions here

\def\hb{\hbox to 10.7 cm{}}

%%%%%%%%%%% End of definitions
\begin{document}

\pagestyle{headings}
\def\thepage{}

\begin{frontmatter}          % The preamble begins here.
%
%\pretitle{}
\title{T\textsubscript{T}: A Formal Theory For Knowledge\\
Representation And Reasoning}

\markboth{}{February 2016\hb}
%\runningtitle{}
%\subtitle{}

% For one author:
\author{\fnms{Enrique} \snm{P\'erez Arnaud}
\thanks{Calle Gallos 12, 41003 Sevilla, Spain; E-mail: enrique@cazalla.net}}
%
% Two or more authors:
%\author[A]{\fnms{} \snm{}},
%\author[B]{\fnms{} \snm{}}
%\runningauthor{}
%\address[A]{}
%\address[B]{}
%
\begin{abstract}
T\textsubscript{T} is a first order formal theory, intended to be used in
the development of systems for knowledge representation and reasoning.
Knowledge, as it is available for us, is expressed in the natural languages.
Therefore, a system for knowledge representation will be more effective
the more its expressive power approaches that of the natural languages:
the easier it is to translate into it any already held knowledge, from its
original expression in some natural language.
One of the main differences in expressive power between formal and natural
languages is given by the
syntactic mismatch between the predicates of the natural
languages and those of the formal languages. This mismatch is due to the fact
that the logical form of the natural languages seems to be first order, but,
at the  same time, predicates are liberally quantified as if there
actually were higher order variables.
So, while in the natural languages we enjoy this freedom from order,
in formal languages we must constraint the predicates by the order of
the system where they occur.
In T\textsubscript{T}, we attempt to overcome this
mismatch by reducing the set of natural language predicates that are
put in correspondence with logical predicates to just the copular predicates,
and by modeling the rest of the predicates as formal operations,
in which the (non-copular) verbs are represented by mere logical contants.
\end{abstract}

\begin{keyword}
knowledge representation and reasoning\sep rule system\sep
logic programming\sep ontology language
\end{keyword}

\end{frontmatter}
\markboth{February 2016\hb}{February 2016\hb}

%%%%%%%%%%% The article body starts:

\section{Introduction}
T\textsubscript{T} was developed from the starting point of axiomatic set
theory, and so, even though its purpose is quite different, I will introduce
it in its relation with set theory. The intent of T\textsubscript{T} is more
along the lines of knowledge representation and reasoning, in contrast to set
theory, intended as a foundation for mathematics.

The particular formulation of set theory that I will use as reference is the
system laid out by A. A. Fraenkel, in his introduction to
"Axiomatic Set Theory" by Paul Bernays \cite{r1}, and which he called system Z
(for Zermelo, beacuse it was mainly based on Zermelo's 1908 system \cite{r2}).
I rely on this system just for the clarity and brevity of its exposition, rather
than for any particular dependence on this formulation of set theory.

\subsection{Fraenkel's System Z}
Fraenkel classified the axioms of system Z into 3 groups. The first group,
under the title "equality and extensionality", played the role of
establishing the interrelations between the 3 basic predicates of the theory
(denoted here by $\in$, $\subseteq$, and =). In this group,
Fraenkel put the axioms of extensionality and equality, and the definition of
subset.

The 2\textsuperscript{nd} group, which Fraenkel called "constructive axioms",
included the axioms of pairing, of sum-set, of power-set, and of subsets. (The
3\textsuperscript{rd} group included just the axiom of choice.)
The role of this 2\textsuperscript{nd} group of axioms is to
guarantee the existence of certain sets.  In the words of Fraenkel:
"Constructive means that, certain things (one set, two sets, a set and a
predicate) being given, the axiom states the existence of a uniquely determined
other set" \cite{r1}.

As pointed out above above, the development of axiomatic set theory was
intended as an effort to provide a foundation for all mathematics; in the words
of Fraenkel, "setting up a comprehensive axiom system [...] in which the
axiomatic theories of other disciplines can be embedded" \cite{r1}. The idea is
to have a very rich universe of sets determined by a short list of axioms, so
that we can explore the internal structure of this universe (by means of
infering theorems from the basic axioms) and extrapolate it to other
disciplines. The 2\textsuperscript{nd} group of axioms in system Z serves the
purpose of populating this rich universe of sets.

\subsection{Taxonomies}
If we just take the first group of Z's axioms (equality and extensionality),
we obtain a theory that is trivially consistent and complete. It is also
quite useless by itself. We cannot infer any theorem, there is no set of which
we can talk. These axioms basically say that if something belongs to a set,
and this set is the subset of another set, the "something" also belongs to the
second set; or that if 2 sets have the same elements, they are equal.  They
give form to the concept of classification, but they do not guarantee that
there are things to classify.  The interpretation of this theory can be reduced
to an empty universe. Obviously, we need the "constructive" axioms to make
something useful out of it.

There might be, however, another way of using that first group of axioms,
to make what could be called formal classifications, or perhaps taxonomies.
In this sense, what we would do is to define individuals (sets) axiomatically,
\textit{ad hoc}, to represent the classes and the objects that we want to classify.
For example, and stretching the meaning of "set" a little bit (since the
modern concept of set includes the constructive axioms mentioned above),
we might define an "animal" set, and a "mammal" subset of "animal",
and a "feline" subset of mammal; and we might define an individual
"Felix the cat", and state (axiomatically) that it belongs in "feline".
From all this, we would have, as theorems, that Felix the cat is an animal,
and also a mammal.

This classificatory knowledge is the knowledge normally expressed
in the natural languages through the use of the verb "to be" in
copular sentences: A mammal is an animal, Felix is a cat, etc.

To actually build such a formal taxonomy, we could not have the same exact
axioms as system Z, due to the fact that universal extensionality would
preclude different empty individuals (ur-elements). In any case, without
constructive axioms, it is trivial to prove the consistency and completeness
of any such system. If, for simplicity, we assume a theory without equality,
we might use just a couple of axioms such as:

\begin{equation}
\forall\,\mathbf{x\mathrm{,\mathbf{y\mathrm{,\mathbf{z}:\;\left(\mathbf{x\in y}\right)\;\bigwedge\;\left(\mathbf{y\subseteq\mathbf{z}}\right)\rightarrow\left(\mathbf{x\in\mathbf{z}}\right)}}}}
\end{equation}

\begin{equation}
\forall\,\mathbf{x\mathrm{,\mathbf{y\mathrm{,\mathbf{z}:\;\left(\mathbf{x\subseteq y}\right)\;\bigwedge\;\left(\mathbf{y\subseteq\mathbf{z}}\right)\rightarrow\left(\mathbf{x\subseteq\mathbf{z}}\right)}}}}
\end{equation}

\subsection{Extending Taxonomies: Natural vs Formal Predicates}
These "formal taxonomy" theories have limited usefulness. They allow us to
represent, in a formal or mechanical system, a certain knowledge that we
previously had informally, as expressed in a natural language. However,
in general this falls short, and we additionally want to say other things about
the classified objects: We usually want to represent other kind of knowledge
in addition to "taxonomic" knowledge. In the natural languages we represent
this knowledge in the same way we represent taxonomic knowledge, that is,
using additional predicates: conjugated verbs, modified by adverbs and objects.

There are many formal systems that incorporate this basic classificatory logic.
From the class systems of object oriented programming languages,
to type systems in functional languages, etc. As regards knowledge representation,
there have been numerous proposals for formal systems where,
on top of a class system without constructive axioms, there are
additional techniques to express arbitrary knowledge.
The  logical positivists of the 1\textsuperscript{st} half of the
20\textsuperscript{th} century were all about that;
an example of their proposals may be found in \cite{r3}.
A more recent example can be found in the OWL of the semantic web,
where there are relations (such as rdfs:subClassOf, etc.)
to express clasification knowledge, and then there are relations to express
any other kind of knowledge \cite{r4}. At least to my knowledge, all these
systems have something in common: the arbitrary knowledge is expressed through
formal predicates, just the same as the taxonomic knowledge.

This presents a problem, because natural language predicates and formal
predicates are quite different things. This difference is quite clearly
manifested in the way variables range over predicates. In a formal language,
a variable that ranges over predicates has to be high order.
The natural languages, in contrast, do not appear to have high
order variables \cite{r5}, but, in spite of this, seem to allow
variables that range over predicates. As an ilustration of this,
we can consider that to the question "what does she want?", both "that apple"
and "to go to the cinema" are (synctactically) acceptable answers.
If we try to "formalize" (express in an \textit{ad hoc} formal language)
those question and answers, we would
want to take "what" as a variable, and the answers to the question as
syntactic objects that belong to the range of that variable.
Then, "that apple" would most naturally correspond to a basic atom,
and so, we would have to assume that the "what" variable is first order.
But "to go to the cinema" would clearly correspond to a predicate,
that shouldn't be in the range of a first order variable.

An example of this problem may be seen in the OWL Full sublanguage of
the semantic web, where it is possible to treat classes as individuals
\cite{r6}. This is equivalent to saying that we can have (first order)
variables ranging over predicates, because OWL
allows for anonymous classes defined from predicates. This provides a
language that has a higher expressive power compared to the other OWL
sublanguages, nearing the expressive power of the natural languages;
but it makes OWL Full undecidable, so that we cannot have dependable
reasoning systems for it.

What is proposed in T\textsubscript{T} is to use an operation
(rather than predicates) to express "non-taxonomic" knowledge.

\section{The Theory T\textsubscript{T}}
The individuals of T\textsubscript{T} are called "words", and they comply with
the axioms (1) and (2) above. As respects their use in T\textsubscript{T},
we might read $\in$ as "is a", and $\subseteq$ as "is a subword of".
Here, I will represent logical variables
by \textbf{x}, \textbf{y}, \textbf{z}, and \textbf{w}, and words
by any other strings of boldface lowercase alphanumeric
characters. We axiomatically add a first word, denoted by \textbf{word}:

\begin{equation}
\forall\,\mathbf{x:\;x\in word}
\end{equation}

Now, we introduce an operator with which we can build triplets, denoted by [ ].
As operations, these triplets have word value, and so, can be related to
other words through $\in$ and $\subseteq$. To introduce this operator,
we first define a new word, \textbf{verb}:

\begin{equation}
\mathbf{verb\subseteq word}
\end{equation}

\begin{equation}
\forall\;\mathbf{x\mathrm{,\mathbf{y\mathrm{,\mathbf{z}:\;\mathbf{\left(\mathbf{y\in\mathbf{verb}}\right)\rightarrow\left(\left[\mathbf{x\; y\; z}\right]\in y\right)}}}}}
\end{equation}

In (4), we define \textbf{verb} as a word that can contain other words
(it is a a subword of \textbf{word}), and in (5) we guarantee that each verb
(each word that $\in$ \textbf{verb}) "contains" all the triplets that can be
formed with itself as middle term in the triplet. This is just a device to
introduce the triplet operator and guarantee the existence of
any possible triplet where the middle term is a verb.

Finally, we define one last word, \textbf{fact}, that allows us to distinguish
certain triplets (which we call facts):

\begin{equation}
\mathbf{fact\subseteq word}
\end{equation}

\begin{equation}
\forall\;\mathbf{x\mathrm{,\mathbf{y\mathrm{,\mathbf{z}:\;\left(\left[\mathbf{x\; y\; z}\right]\in \mathbf{fact}\right)}\mathbf\rightarrow\left(\mathbf{y\in\mathbf{verb}}\right)}}}
\end{equation}

So, in (6) we introduce the word \textbf{fact}
and in (7) we indicate that we can choose certain triplets and mark
them as facts. We can choose whatever triplets we want as facts,
and set them as postulates, and add any number of rules
to derive consecuences from those postulated facts,
all in acordance to whatever particular pieces of "natural knowledge"
we want to represent.

\subsection{An Example}

As an example, I will sketch the access control logic for a
document management system. The main classes of objects we will deal with,
in this system, are people and documents.

\begin{equation}
  \mathbf{person \subseteq word}
\end{equation}

\begin{equation}
  \mathbf{document \subseteq word}
\end{equation}

We can have people and documents:

\begin{equation}
  \mathbf{bob \in person}
\end{equation}
\begin{equation}
  \mathbf{doc1 \in document}
\end{equation}

People can do things with documents: they can view them, or edit them:

\begin{equation}
  \mathbf{doc\-/action \in verb}
\end{equation}
\begin{equation}
  \mathbf{view \subseteq doc\-/action}
\end{equation}
\begin{equation}
  \mathbf{edit \subseteq doc\-/action}
\end{equation}

So, to represent that Bob views doc1, we would assert:

\begin{equation}
  \mathbf{\left[bob\; view\; doc1\right] \in fact}
\end{equation}

Now we define a verb \textbf{want}, that has a predicate as object.
The idea is to have rules that, when presented with a fact
where a person wants to do something with a document,
can determine whether the  person gets to do the requested action:

\begin{equation}
  \mathbf{want \in verb}
\end{equation}

To represent that Bob wants to see doc1:

\begin{equation}
  \mathbf{\left[bob\; want\; \left[bob\; view\; doc1\right]\right] \in fact}
\end{equation}

Now we need permissions:

\begin{equation}
  \mathbf{permission \subseteq word}
\end{equation}
\begin{equation}
  \mathbf{view\-/perm \in permission}
\end{equation}
\begin{equation}
  \mathbf{edit\-/perm \in permission}
\end{equation}

A permission can protect a document action:

\begin{equation}
  \mathbf{is\-/protected\-/by \in verb}
\end{equation}

So that to represent that the edit action is pretected by the edit\-/perm permission,
we assert:

\begin{equation}
  \mathbf{\left[edit\; is\-/protected\-/by\; edit\-/perm\right] \in fact}
\end{equation}

Finally, a person can be granted a certain permission:

\begin{equation}
  \mathbf{has\-/permission \in verb}
\end{equation}

And, to say that bob has the edit\-/perm permission:

\begin{equation}
  \mathbf{\left[bob\; has\-/permission\; edit\-/perm\right] \in fact}
\end{equation}

Now we can produce a rule where we say that if a person
wants to perform some action with a document,
that action is protected by some permission,
and the person has that permission,
the person gets to do it:

\begin{equation}
  \begin{array}{ll}  \forall\;\mathbf{x}\mathrm{,}\mathbf{y}\mathrm{,}\mathbf{z}\mathrm{,}\mathbf{w}\mathrm{:} & \;\mathbf{\left(x \in person\right)}\bigwedge \\ {} &  \mathbf{\left(y \subseteq doc\-/action\right)}\bigwedge \\ {} &  \mathbf{\left(z \in y\right)}\bigwedge \\ {} &  \;\mathbf{\left(w \in permission\right)}\bigwedge \\ {} & \mathbf{\left(\left[x\; want\; z\right] \in fact\right)}\bigwedge \\ {} &  \mathbf{\left(\left[x\; has\-/permission\; w\right] \in fact\right)}\bigwedge \\ {} &  \mathbf{\left(\left[y\; is\-/protected\-/by\; w\right] \in fact\right)} \\ {} &  \rightarrow \\ {} &  \mathbf{\left(z \in fact\right)}\end{array}
\end{equation}

Let's examine this rule in some detail.
the 1st condition constraints \textbf{x} to be \textbf{bob};
the second condition constraints \textbf{y} to be \textbf{edit} or \textbf{view};
the  3rd condition constraints \textbf{z} to be a triplet where the verb is \textbf{y};
and the 4th \textbf{w} to be a  permission.
Then, if \textbf{x} wants \textbf{z} (to do something with some document)
and has the permission needed to do it,
\textbf{z} happens.

If we now  add these sentences:

\begin{equation}
  \mathbf{\left[bob\; has\-/permission\; view\-/perm\right] \in  fact}
\end{equation}
\begin{equation}
  \mathbf{\left[view\; is\-/protected\-/by\; view\-/perm\right] \in fact}
\end{equation}
\begin{equation}
  \mathbf{\left[bob\; want\; \left[bob\; view\; doc1\right]\right] \in fact}
\end{equation}

Since \textbf{bob} can substitute \textbf{x},
and \textbf{view\-/perm} can substitue \textbf{w},
and \textbf{view} can substitute \textbf{y},
and \textbf{[bob view doc1]} can substitute \textbf{z},
we would have a  theorem that says that

\begin{equation}
  \mathbf{\left[bob\; view\; doc1\right] \in fact}
\end{equation}

And the thing to note here is that all variables are
the same  kind, the same order, with  such different words in their range as
\textbf{bob}, \textbf{view}, and \textbf{[bob view doc1]},
standing for, respectively, a proper name, a verb, and a fact.

\subsection{(Almost) Unrestricted Comprehension.}

To add to the previous example, we might consider a rule that comes close to
\textit{unrestricted comprehension} (UC), but that stays just clear of
the antinomies encountered by  Bertrand Russell when examining UC
as proposed by Gottlob Frege.

\begin{equation}
  \forall\;\mathbf{x}\mathrm{,}\mathbf{y}\mathrm{,}\mathbf{z}\;\exists\;\mathbf{w}\mathrm{:} \;\mathbf{\left(\left[x\; y\; z\right] \in fact\right)} \rightarrow \mathbf{\left(x \in w\right)}
\end{equation}

This rule asserts that for every verb-object pair \textbf{y z}
(corresponding to an arbitrary natural language non-copular predicate),
there exists a word \textbf{w} that contains all words \textbf{x} that
produce a true proposition with it. This is
functionally very close to UC, but, since it excludes set-theoretic
predicates (i.e. the only possible logical predicates in T\textsubscript{T}),
and Russell's paradox requires those, it
does not introduce by itself inconsistencies into our theories.

\subsection{A proof of concept.}

There is an implementation of a system based on the ideas laid out in
this paper, published as free open source software, available at \cite{r7}.

\clearpage

%%%%%%%%%%% The bibliography starts:
\begin{thebibliography}{99}

\bibitem{r1}
\textit{Axiomatic Set Theory}. Paul Bernays.
    2\textsuperscript{nd} ed. Amsterdam: North Holland Pub. Co. (1968)

\bibitem{r2}
  \textit{Untersuchungen über die Grundlagen der Mengenlehre I}. Ernst Zermelo.
  Mathematische Annalen 65 (2): 261–281 (1908)

\bibitem{r3}
  \textit{Introduction to Symbolic Logic and its Applications}. Rudolf Carnap.
    New York: Dover Publications Inc. (1958)

\bibitem{r4}
  \textit{OWL Web Ontology Language Reference}. W3C Recommendation.
    https://www.w3.org/TR/owl-ref/ (Retrieved 2016-01-10)

\bibitem{r5}
  \textit{Variables in natural language}. Meredith Lizabeth Landman.
  Doctoral Dissertations Available from Proquest. Paper AAI3206213. (2006)

\bibitem{r6}
  \textit{A semantic Web Primer}. Grigoris Antoniou and Frank van Harmelen.
    Cambridge, Ma: The MIT Press (2004)

\bibitem{r7}
  \textit{Terms Documentation} Enrique P\'erez Arnaud.
  http://terms.readthedocs.org/en/latest/ Retrieved 2016-01-10


\end{thebibliography}
\end{document}
